const varId = name => {
  const lastFunc = scopes[scopes.lastFuncs.at(-1)];
  lastFunc._variableIds ??= Object.create(null);
  lastFunc._variableIds[name] ??= 0;
  return lastFunc._variableIds[name]++;

  // scopes._varId ??= Object.create(null);
  // scopes._varId[name] ??= 0;
  // return scopes._varId[name]++;
};

const declVar = (name, kind, node) => {
  let parent;
  if (kind === 'var') {
    parent = scopes[scopes.lastFuncs.at(-1)];
    // same id for redecl
    if (parent._variables?.[name]) {
      parent._variables[name].node = node;
      return;
    }
  } else {
    parent = scopes.at(-1);
  }

  parent._variables ??= Object.create(null);
  parent._variables[name] = { node, id: varId(name) };
};

const analyzePattern = (kind, node) => {
  if (!node) return;
  switch (node.type) {
    case 'Identifier':
      declVar(node.name, kind, node);
      break;

    case 'RestElement':
      analyzePattern(kind, node.argument);
      break;

    case 'AssignmentPattern':
      analyzePattern(kind, node.left);
      break;

    case 'Property':
      analyzePattern(kind, node.value);
      break;

    case 'ObjectPattern':
      for (const x of node.properties) {
        analyzePattern(kind, x.value);
      }
      break;

    case 'ArrayPattern':
      for (const x of node.elements) {
        analyzePattern(kind, x);
      }
      break;
  }
};

let scopes;
const analyze = (node, strict = false) => {
  if (!node) return;

  const top = scopes.at(-1);
  if (node.directive === 'use strict') {
    top._strict = true;
  }

  let openedScope = false;
  switch (node.type) {
    case 'ForStatement':
    case 'ForInStatement':
    case 'ForOfStatement':
    case 'SwitchStatement':
    case 'BlockStatement':
      scopes.push(node);
      openedScope = true;
      break;

    case 'CatchClause':
      scopes.push(node);
      if (node.param) analyzePattern('let', node.param);
      openedScope = true;
      break;

    case 'VariableDeclaration':
      for (const x of node.declarations) analyzePattern(node.kind, x.id);
      break;

    case 'ClassDeclaration':
      if (node.id?.name) declVar(node.id.name, 'let', node);
      break;

    case 'FunctionDeclaration':
      if (node.id?.name) declVar(node.id.name, strict ? 'let' : 'var', node);
    case 'FunctionExpression':
    case 'ArrowFunctionExpression':
      scopes.lastFuncs.push(scopes.length);
      scopes.push(node);
      openedScope = true;

      for (const p of node.params) analyzePattern('var', p);
      break;
  }

  for (const x in node) {
    if (node[x] != null && typeof node[x] === 'object') {
      if (node[x].type) analyze(node[x], strict || top._strict);
      if (Array.isArray(node[x])) {
        for (const y of node[x]) analyze(y, strict || top._strict);
      }
    }
  }

  if (openedScope) {
    scopes.pop();
  }

  if (node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression') {
    scopes.lastFuncs.pop();
  }
};

const objectHackers = ["assert","compareArray","Test262Error","Number","Math","Porffor","performance","String","ByteString","Array","ArrayBuffer","SharedArrayBuffer","Atomics","ecma262","BigInt","Boolean","console","crypto","DataView","Date","Error","AggregateError","TypeError","ReferenceError","SyntaxError","RangeError","EvalError","URIError","Test262Error","Function","JSON","Map","Object","Promise","Reflect","RegExp","Set","Symbol","Uint8Array","Int8Array","Uint8ClampedArray","Uint16Array","Int16Array","Uint32Array","Int32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array","WeakMap","WeakRef","WeakSet","navigator"];
const annotate = node => {
  if (!node) return;

  let openedScope = false;
  if (node._variables) {
    scopes.push(node);
    openedScope = true;
  }

  // track captured variables
  // if a function accesses a variable from a parent scope (that is not the global scope), it is captured
  if (node.type === 'Identifier' && !objectHackers.includes(node.name)) {
    for (let i = scopes.length - 1; i >= 0; i--) {
      const scope = scopes[i];
      if (scope._variables?.[node.name]) {
        // found declaration
        const variable = scope._variables[node.name];
        if (variable.id > 0) node.name = node.name + '#' + variable.id;

        // check if captured
        // if declared in a different function scope than current
        const declScopeIndex = i;
        const currentFuncIndex = scopes.lastFuncs.at(-1);

        // find which function scope the declaration belongs to
        // traverse up from declScopeIndex until we find a function or root
        let declFuncIndex = -1;
        // if declaration is in a function, it's that function
        // if in a block in a function, it's that function
        // if in root, it's 0 (main)

        // simple check: is the scope of declaration inside the current function?
        // if not, it is captured
        // we can check if declScopeIndex is <= currentFuncIndex (assuming scopes are pushed in order)
        // but scopes array changes.

        // Robust check:
        // 1. Identify the function owning the declaration.
        // 2. Identify the function owning the usage (current).
        // 3. If they differ and decl is not global (index 0), it's captured.

        // Find decl func index
        // semantic.js structure is a bit flat, scopes is just a stack of nodes.
        // we need to know which scopes correspond to functions.
        // scopes.lastFuncs tracks indices of functions in `scopes` stack.

        let declOwnerFuncIndex = -1;
        // find the nearest function scope at or above declScopeIndex
        // iterate lastFuncs, find largest index <= declScopeIndex
        for (let j = scopes.lastFuncs.length - 1; j >= 0; j--) {
          if (scopes.lastFuncs[j] <= declScopeIndex) {
            declOwnerFuncIndex = scopes.lastFuncs[j];
            break;
          }
        }

        const usageOwnerFuncIndex = scopes.lastFuncs.at(-1);

        if (declOwnerFuncIndex !== -1 && declOwnerFuncIndex !== usageOwnerFuncIndex && declOwnerFuncIndex !== 0) {
          // Captured!
          const declFunc = scopes[declOwnerFuncIndex];
          declFunc._captured ??= new Set();
          declFunc._captured.add(node.name);

          // Mark variable as captured in its metadata
          variable.captured = true;

          // Propagate capture requirement down to usage
          // Every function between decl and usage needs to capture it too (to pass it down)
          // (Closure chain)
          // start from usage func, go up to decl func (exclusive)
          for (let k = scopes.lastFuncs.length - 1; k >= 0; k--) {
            const funcIndex = scopes.lastFuncs[k];
            if (funcIndex === declOwnerFuncIndex) break;

            const intermediateFunc = scopes[funcIndex];
            intermediateFunc._captured ??= new Set();
            intermediateFunc._captured.add(node.name);
          }
        }

        break;
      }
    }
  }

  switch (node.type) {
    case 'Identifier':
      break;

    case 'MemberExpression':
      if (node.computed) annotate(node.property);
      annotate(node.object);
      return;

    case 'PropertyDefinition':
    case 'Property':
      if (node.computed) annotate(node.key);
      annotate(node.value);
      return;

    case 'CallExpression':
      if (node.callee.name === 'eval' || (node.callee.type === 'SequenceExpression' && node.callee.expressions.at(-1)?.name === 'eval')) {
        if (node.callee.type === 'SequenceExpression' || node.optional) {
          // indirect eval, only top scope
          node._semanticScopes = [ scopes[0], node ];
          node._semanticScopes.lastFuncs = [ 0 ];
        } else {
          // direct eval, use existing scope
          node._semanticScopes = Object.assign([], scopes);
          node._semanticScopes.push(node);
        }
      }

    case 'NewExpression':
      if (node.callee.name === 'Function') {
        // new Function(...) - use global scope and self as scope
        node._semanticScopes = [ scopes[0], node ];
        node._semanticScopes.lastFuncs = [ 0, 1 ];
      }
      break;
  }

  for (const x in node) {
    if (node[x] != null && typeof node[x] === 'object' && x[0] !== '_') {
      if (node[x].type) annotate(node[x]);
      if (Array.isArray(node[x])) {
        for (const y of node[x]) annotate(y);
      }
    }
  }

  if (openedScope) {
    scopes.pop();
  }
};

export default (node, _scopes = null) => {
  if (!_scopes) {
    _scopes = [ node ];
    _scopes.lastFuncs = [ 0 ];
  }
  scopes = _scopes;

  analyze(node);
  if (scopes.length !== _scopes.length) throw new Error('Scope mismatch');

  annotate(node);
  return node;
};